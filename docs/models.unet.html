---

title: U-Net


keywords: fastai
sidebar: home_sidebar



nb_path: "nbs/06d_models.unet.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/06d_models.unet.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">body_3d</span> <span class="o">=</span> <span class="n">create_body</span><span class="p">(</span><span class="n">r3d_18</span><span class="p">,</span> <span class="n">pretrained</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Dynamic-Unet-3D">Dynamic Unet 3D<a class="anchor-link" href="#Dynamic-Unet-3D"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Fastai's <code>DynamicUnet</code> allows construction of a UNet using any pretrained CNN as backbone/encoder. A key module is <code>nn.PixelShuffle</code> which allows subpixel convolutions for upscaling in the UNet Blocks. However, <code>nn.PixelShuffle</code> is only for 2D images, so in faimed3d <code>nn.ConvTranspose3d</code> is used instead.</p>

</div>
</div>
</div>
    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ConvTranspose3D" class="doc_header"><code>class</code> <code>ConvTranspose3D</code><a href="https://github.com/kbressem/faimed3d/tree/master/faimed3d/models/unet.py#L18" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ConvTranspose3D</code>(<strong><code>ni</code></strong>, <strong><code>nf</code></strong>=<em><code>None</code></em>, <strong><code>scale</code></strong>=<em><code>2</code></em>, <strong><code>blur</code></strong>=<em><code>False</code></em>, <strong><code>act_cls</code></strong>=<em><code>None</code></em>, <strong><code>norm_type</code></strong>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>) :: <code>Sequential</code></p>
</blockquote>

<pre><code>Upsample by 2` from `ni` filters to `nf` (default `ni`), using `nn.ConvTranspose3D`.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Fastai's <code>PixelShuffle_ICNR</code> first performes a convolution to increase the layer size, then applies <code>PixelShuffle</code> to resize the image. A special initialization technique is applied to <code>PixelShuffle</code>, which can reduce checkerboard artifacts (see <a href="https://arxiv.org/pdf/1707.02937.pdf">https://arxiv.org/pdf/1707.02937.pdf</a>). It is probably not needed for <code>nn.ConvTranspose3d</code></p>

</div>
</div>
</div>
    {% raw %}

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ConvTranspose3D</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">128</span><span class="p">)(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">)))</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([1, 128, 5, 15, 15])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ConvTranspose3D</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">blur</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">)))</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([1, 128, 5, 15, 15])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To work with 3D data, the <code>UnetBlock</code> from fastai is adapted, replacing <code>PixelShuffle_ICNR</code> with the above created <a href="/models.unet.html#ConvTranspose3D"><code>ConvTranspose3D</code></a> and also adapting all conv-layers and norm-layers to the 3rd dimension. As small differences in size may appear, <code>forward</code>-func contains a interpolation step, which is also adapted to work with 5D input instead of 4D.<br>
<a href="/models.unet.html#UnetBlock3D"><code>UnetBlock3D</code></a> receives the lower level features as hooks. In contrast to <code>fastai</code>, the hooks are a list of tensors with <code>len(hook) == n_inp</code>, where <code>n_inp</code> is the number of 3D sequences in a 4D dimensional input. <strong>Important</strong> 4D here does not refer to the dimensionality of the Tensor, where 4D would be B x C x H x W but to the dimensionality of the input <strong>before</strong> it was concatenated to a Tensor. 3D means we have one 3D volume with dimensionality (C) x D x H x W and 4D means we have multiple 3D volumes. In medical imaging, this is not rare, as we often wish to use information from multiple imaging sequences.
The information from the different sequences can be assumed to be redundant to some kind, so in the <a href="/models.unet.html#UnetBlock3D"><code>UnetBlock3D</code></a>, first the different feature maps from the hooks are concatenated and then pooled using a 1x1x1 convolutional layer. After this, the class is built similar to the fastai <code>UnetBlock</code></p>

</div>
</div>
</div>
    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="UnetBlock3D" class="doc_header"><code>class</code> <code>UnetBlock3D</code><a href="https://github.com/kbressem/faimed3d/tree/master/faimed3d/models/unet.py#L29" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>UnetBlock3D</code>(<strong><code>up_in_c</code></strong>, <strong><code>x_in_c</code></strong>, <strong><code>hook</code></strong>, <strong><code>final_div</code></strong>=<em><code>True</code></em>, <strong><code>blur</code></strong>=<em><code>False</code></em>, <strong><code>act_cls</code></strong>=<em><code>ReLU</code></em>, <strong><code>self_attention</code></strong>=<em><code>False</code></em>, <strong><code>init</code></strong>=<em><code>kaiming_normal_</code></em>, <strong><code>norm_type</code></strong>=<em><code>None</code></em>, <strong><code>ks</code></strong>=<em><code>3</code></em>, <strong><code>stride</code></strong>=<em><code>1</code></em>, <strong><code>padding</code></strong>=<em><code>None</code></em>, <strong><code>bias</code></strong>=<em><code>None</code></em>, <strong><code>ndim</code></strong>=<em><code>2</code></em>, <strong><code>bn_1st</code></strong>=<em><code>True</code></em>, <strong><code>transpose</code></strong>=<em><code>False</code></em>, <strong><code>xtra</code></strong>=<em><code>None</code></em>, <strong><code>bias_std</code></strong>=<em><code>0.01</code></em>, <strong><code>dilation</code></strong>:<code>Union</code>[<code>int</code>, <code>Tuple</code>[<code>int</code>, <code>int</code>]]=<em><code>1</code></em>, <strong><code>groups</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>padding_mode</code></strong>:<code>str</code>=<em><code>'zeros'</code></em>) :: <code>Module</code></p>
</blockquote>

<pre><code>A quasi-UNet block, using `ConvTranspose3d` for upsampling`.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The output size of the last Unet-Block can be slightly different than the original input size, so one of the last steps in <code>DynamicUnet</code> is <a href="/models.unet.html#ResizeToOrig"><code>ResizeToOrig</code></a> which is also adapted to work with 5D instead of 4D input images.</p>

</div>
</div>
</div>
    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ResizeToOrig" class="doc_header"><code>class</code> <code>ResizeToOrig</code><a href="https://github.com/kbressem/faimed3d/tree/master/faimed3d/models/unet.py#L56" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ResizeToOrig</code>(<strong><code>mode</code></strong>=<em><code>'nearest'</code></em>) :: <code>Module</code></p>
</blockquote>

<pre><code>Merge a shortcut with the result of the module by adding them or concatenating them if `dense=True`.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>SequentialEx</code> does not allow to pass more than one item to <code>forward</code>, so it is subclassed to allow tuples. Also the input needs to pass the first two blocks outside of the loop, as inputs are a tuple/list at this state. Block two concatenates the input to a single tensor, which can then be passed to the loop.</p>

</div>
</div>
</div>
    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SequentialEx4D" class="doc_header"><code>class</code> <code>SequentialEx4D</code><a href="https://github.com/kbressem/faimed3d/tree/master/faimed3d/models/unet.py#L65" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SequentialEx4D</code>(<strong>*<code>layers</code></strong>) :: <code>SequentialEx</code></p>
</blockquote>

<pre><code>Like `SequentialEx`, but handels orig data differently and allows to pass a tuple/list as input</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>faimed3d</code> needs to support 4D data, that is multiple 3D inputs. The reason a radiologist uses multiple sequences is that some information is only present in a certain sequence. For example, to make the diagnosis of stroke, one needs a strong hyperintense signal in the DWI and also a corresponding hypointense signal on the ADC map. It is (nearly) impossible to make a diagnosis only from one sequence. When we build a model, we also want it to have access to all relevant information.<br>
The way fastai handels mulitple inputs is to store them in a tuple. So if we have two 3D volumes as input and one mask as target, the batch will be as follows:<br>
(TensorDicom3D of size B x 3 x D x H W, TensorDicom3D of size B x 3 x D x H x W, TensorMask3D of size B x 3 x D x H x W).
<code>faimed3d</code> assumes, that all sequences are of roughly the same orientation (e.g. all axial) and also of the same region. So, information in the sequences can be assumed to be redundant to some extent and likely one does not need an encoder for each sequence and can re-use the weights of one encoder for all images. This approach saves a lot of memory, but makes the training longer. However, it might be beneficial to still have some different weights for each sequence. For this reason, <code>faimed3d</code> splits a given encoder into its stem and main body and duplicates the stem according to the number of inputs using the <code>MultiStem</code> class.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="/models.unet.html#DynamicUnet3D"><code>DynamicUnet3D</code></a> is the main UNet class for <code>faimed3d</code> and is very similar to the <code>fastai</code> <code>DynamicUnet</code>.
Key differences are the adaption to 3D and 4D inputs. In <code>fastai</code> <code>DynamicUnet</code> the feature maps are stored as hook, each time the size of the feature maps changes in the encoder. In <code>faimed3d</code> we can have multiple inputs but only one encoder and the hooks return a list of tensors. This is adressed by adapting <code>model_sizes</code>, <code>dummy_eval</code>, adding an extra concat-layer and adapting the <code>UNetBlock</code></p>

</div>
</div>
</div>
    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="AddItems" class="doc_header"><code>class</code> <code>AddItems</code><a href="https://github.com/kbressem/faimed3d/tree/master/faimed3d/models/unet.py#L80" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>AddItems</code>() :: <code>Module</code></p>
</blockquote>

<pre><code>add items in a list</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DynamicUnet3D" class="doc_header"><code>class</code> <code>DynamicUnet3D</code><a href="https://github.com/kbressem/faimed3d/tree/master/faimed3d/models/unet.py#L89" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DynamicUnet3D</code>(<strong><code>encoder</code></strong>, <strong><code>n_out</code></strong>, <strong><code>img_size</code></strong>, <strong><code>n_inp</code></strong>=<em><code>1</code></em>, <strong><code>blur</code></strong>=<em><code>False</code></em>, <strong><code>blur_final</code></strong>=<em><code>True</code></em>, <strong><code>self_attention</code></strong>=<em><code>False</code></em>, <strong><code>y_range</code></strong>=<em><code>None</code></em>, <strong><code>last_cross</code></strong>=<em><code>True</code></em>, <strong><code>bottle</code></strong>=<em><code>False</code></em>, <strong><code>act_cls</code></strong>=<em><code>ReLU</code></em>, <strong><code>init</code></strong>=<em><code>kaiming_normal_</code></em>, <strong><code>norm_type</code></strong>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>) :: <a href="/models.unet.html#SequentialEx4D"><code>SequentialEx4D</code></a></p>
</blockquote>

<pre><code>Create a U-Net from a given architecture.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">unet3d</span> <span class="o">=</span> <span class="n">DynamicUnet3D</span><span class="p">(</span><span class="n">body_3d</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">unet3d</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([2, 2, 10, 50, 50])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">unet4d</span> <span class="o">=</span> <span class="n">DynamicUnet3D</span><span class="p">(</span><span class="n">body_3d</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">unet4d</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([2, 2, 10, 50, 50])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
