# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02-transformation-for-3d-data.ipynb (unless otherwise specified).

__all__ = ['Resize3D', 'RandomFlip3D', 'RandomRotate3D', 'RandomRotate3DBy', 'RandomDihedral3D', 'RandomCrop3D',
           'ResizeCrop3D', 'RandomWarp3D', 'RandomNoise3D', 'RandomBrightness3D', 'RandomContrast3D', 'PseudoColor',
           'aug_transforms_3d']

# Cell
# default_exp augment
import torchvision
import torch
import torch.nn.functional as F
import fastai
from fastai.basics import *
from fastai.vision.augment import *

# Cell
from .basics import *

# Cell

@patch
def resize_3d(t: (TensorDicom3D, TensorMask3D), size, scale_factor=None, mode='nearest', align_corners=None, recompute_scale_factor=None):

    '''
    A function to resize a 3D image using torch.nn.functional.interpolate

    Args:
        t (Tensor): a 3D or 4D Tensor to be resized
        new_dim (int): a tuple with the new x,y,z dimensions of the tensor after resize

    '''

    if t.ndim == 3: t=t.unsqueeze(0)   # add fake chanel dim

    return F.interpolate(t.unsqueeze(0), # add fake batch dim
                         size=size,
                         scale_factor=scale_factor,
                         mode=mode,
                         align_corners=align_corners,
                         recompute_scale_factor=recompute_scale_factor).squeeze() # remove fake dims, returning original 3D or 4D Tensor


class Resize3D(RandTransform):
    split_idx,order = None, 1
    "Resize a 3D image"

    def __init__(self, size, scale_factor=None, mode='nearest', align_corners=None, recompute_scale_factor=None, **kwargs):
        size = _process_sz_3d(size)
        scale_factor = scale_factor
        mode = mode
        align_corners = align_corners
        store_attr()
        super().__init__(**kwargs)

    def encodes(self, x: (TensorDicom3D,TensorMask3D)):
        return x.resize_3d(self.size, self.scale_factor, self.mode, self.align_corners, self.recompute_scale_factor)

def _process_sz_3d(size):
    if len(size) == 2: size=(size[0],size[1], size[1])
    return fastuple(size[0],size[1],size[2])



# Cell

@patch
def flip_ll_3d(t: (TensorDicom3D, TensorMask3D)):
    "flips an image laterolateral"
    return t.flip(-1) # works on 3D images and 4D batchs

@patch
def flip_ap_3d(t: (TensorDicom3D, TensorMask3D)):
    "flips an image anterior posterior"
    return t.flip(-2)

@patch
def flip_cc_3d(t: (TensorDicom3D, TensorMask3D)):
    "flips an image cranio caudal"
    return t.flip(-3)


# Cell

class RandomFlip3D(RandTransform):
    "Randomly flip alongside any axis with probability `p`"
    def __init__(self, p=0.75):
        super().__init__(p=p)

    def before_call(self, b, split_idx):
        "Set `self.do` based on `self.p`"
        self.do = self.p==1. or random.random() < self.p
        self.axis = random.randint(1, 3)*-1  # add a random integer for axis to rotate

    def encodes(self, x:(TensorDicom3D, TensorMask3D)):
        return x.flip(self.axis)

# Cell

@patch
def rotate_90_3d(t: (TensorDicom3D, TensorMask3D)):
    return t.transpose(1, 2) if t.ndim == 3 else t.transpose(2, 3)

@patch
def rotate_270_3d(t: (TensorDicom3D, TensorMask3D)):
    return t.transpose(1, 2).flip(-1) if t.ndim == 3 else t.transpose(2, 3).flip(-1)

@patch
def rotate_180_3d(t: (TensorDicom3D, TensorMask3D)):
    return t.flip(-1).flip(-2)


class RandomRotate3D(RandTransform):
    "Randomly flip rotates the axial slices of the 3D image 90/180 or 270 degrees with probability `p`"
    def __init__(self, p=0.5):
        super().__init__(p=p)

    def before_call(self, b, split_idx):
        "Set `self.do` based on `self.p`"
        self.do = self.p==1. or random.random() < self.p
        self.which = random.randint(1, 3)  # add a random integer for axis to rotate

    def encodes(self, x:(TensorDicom3D, TensorMask3D)):
        if self.which == 1: x = x.rotate_90_3d()
        elif self.which == 2: x = x.rotate_180_3d()
        else: x = x.rotate_270_3d()
        return x if x.device.type == 'cpu' else x.cuda()

# Cell

@patch
def rotate_3d_by(t: (TensorDicom3D,TensorMask3D), angle: (int, float), axes: list):
    '''rotates 2D slices of a 3D tensor.
    Args:
        t: a TensorDicom3D object or torch.tensor
        angle: the angle to rotate the image
        axes: axes to which the rotation should be applied.

    Example:
        If the tensor `t` has the shape of (10, 512, 512), which is equal to 10 slices of 512x512 px.

    rotate_3d_by(t, angle = -15.23, axes = [1,2]) will rotate each slice for -15.23 degrees.

    '''
    typ = type(t)
    if t.ndim == 4: axes = [x+1 for x in axes]

    print(axes)
    rot_t = torch.from_numpy(ndimage.rotate(t.cpu(), angle, axes, reshape=False))
    return retain_type(rot_t, typ = typ)


class RandomRotate3DBy(RandTransform):
    "Randomly flip rotates the axial slices of the 3D image 90/180 or 270 degrees with probability `p`"
    def __init__(self, p=0.5):
        super().__init__(p=p)

    def before_call(self, b, split_idx):
        "Set `self.do` based on `self.p`"
        self.do = self.p==1. or random.random() < self.p
        self.angle = random.randint(-10, 10)  # add a random integer for axis to rotate
        self.axes = random.choice([[0,1],[1,2],[0,2]])

    def encodes(self, x:(TensorDicom3D, TensorMask3D)):
        x = x.rotate_3d_by(angle=self.angle, axes=self.axes)
        return x if x.device.type == 'cpu' else x.cuda()

# Cell

@patch
def dihedral3d(x:(TensorDicom3D,TensorMask3D), k):
    "apply dihedral transforamtions to the 3D Dicom Tensor"
    if k in [6,7,8,9,14,15,16,17]: x = x.flip(-3)
    if k in [4,10,11,14,15]: x = x.flip(-1)
    if k in [5,12,13,16,17]: x = x.flip(-2)
    if k in [1,7,10,12,14,16]:
        if x.ndim == 3: x = x.transpose(1, 2)
        else: x = x.transpose(2,3)
    if k in [2,8]: x = x.flip(-1).flip(-2)
    if k in [3,11,13,15,17]:
        if x.ndim == 3: x = x.transpose(1, 2).flip(-1)
        else: x = x.transpose(2,3).flip(-1)
    return x

class RandomDihedral3D(RandTransform):
    "randomly flip and rotate the 3D Dicom volume with a probability of `p`"
    def before_call(self, b, split_idx):
        super().before_call(b, split_idx)
        self.k = random.randint(0,17)

    def encodes(self, x:(TensorDicom3D,TensorMask3D)):
        x = x.dihedral3d(self.k)
        return x if x.device.type == 'cpu' else x.cuda()

# Cell

@patch
def crop_3d(t: (TensorDicom3D, TensorMask3D), crop_by: (int, float), perc_crop = False):
    "Similar to function `crop_3d_tensor`, but no checking for margin formats is done, as they were correctly passed to this function by RandomCrop3D.encodes"
    typ = type(t)
    if t.ndim not in (3,4): raise TypeError('Tensor of size 3 or 4 expected, but got Tensor of size {} with shape {}'.format(t.ndim, t.shape))
    if t.ndim == 3:
        x, y, z = t.shape
    else:
        _, x, y, z = t.shape
    x1,x2,y1,y2,z1,z2 = crop_by

    if perc_crop:
        if not all(isinstance(i, float) for i in [x1,x2,y1,y2,z1,z2]): raise ValueError('perc_crop should be a float value between 0 and 0.5')
        x1,x2,y1,y2,z1,z2 = int(x1*x),int(x2*x),int(y1*y),int(y2*y),int(z1*z),int(z2*z)

    if t.ndim == 3:
        return retain_type(t[x1:x-x2, y1:y-y2, z1:z-z2], typ = typ)
    else:
        return t[:,x1:x-x2, y1:y-y2, z1:z-z2]


def _get_margins(crop_by):
    cropx, cropy, cropz = crop_by
    try: x1,x2 = cropx
    except: x1,x2 = cropx,cropx
    try: y1,y2 = cropy
    except: y1,y2 = cropy,cropy
    try: z1,z2 = cropz
    except: z1,z2 = cropz,cropz
    return (x1,x2,y1,y2,z1,z2)

def _add_to_margin(add):
    if type(add) is int: return random.randint(-add,add)
    if type(add) is float: return random.uniform(-add, add)



class RandomCrop3D(RandTransform):
    '''
    Randomly crop the 3D volume with a probability of `p`
    The x axis is the "slice" axis, where no cropping should be done by default

    Args
        crop_by: number of pixels or pecantage of pixel to be removed at each side. E.g. if (0, 5, 5), 0 pixel in the x axis, but 10 pixels in eacht y and z axis will be cropped (5 each side)
        rand_crop_xyz: range in which the cropping window is allowed to vary.
        perc_crop: if true, no absolute but relative number of pixels are cropped
    '''
    split_idx, p = None, 1
    def __init__(self, crop_by, rand_crop_xyz, perc_crop=False, p=1, **kwargs):
        super().__init__(p=p,**kwargs)
        self.p = p
        self.crop_by = crop_by
        self.perc_crop = perc_crop
        self.crop_by_x, self.crop_by_y, self.crop_by_z = rand_crop_xyz

    def before_call(self, b, split_idx):
        super().before_call(b, split_idx)

        if type(self.crop_by) is tuple and len(self.crop_by) == 3:
            x1,x2,y1,y2,z1,z2 = _get_margins(self.crop_by)

            self.x_add = _add_to_margin(self.crop_by_x)
            self.y_add = _add_to_margin(self.crop_by_y)
            self.z_add = _add_to_margin(self.crop_by_z)

            self.margins = (x1+self.x_add, x2-self.x_add,
                                y1+self.y_add, y2-self.y_add,
                                z1+self.z_add, z2-self.z_add)

        else:
            raise ValueError('"final_margins" must be a tuple with length 3')

        if any(self.margins) < 0: raise ValueError('cannot crop to a negative dimension')

    def encodes(self, x:(TensorDicom3D,TensorMask3D)):
        x = x.crop_3d(crop_by = self.margins, perc_crop = self.perc_crop)
        return x if x.device.type == 'cpu' else x.cuda()

# Cell

class ResizeCrop3D(RandTransform):
    split_idx,order = None, 1

    "Resize and crop a 3D tensor"

    def __init__(self, crop_by, resize_to, perc_crop=False, p=1, **kwargs):
        resize_to = _process_sz_3d(resize_to)
        crop_by = crop_by
        perc_crop = perc_crop
        store_attr()
        super().__init__(p=p,**kwargs)

    def encodes(self, x:(TensorDicom3D,TensorMask3D)):
        if type(self.crop_by) is tuple and len(self.crop_by) == 3:
            self.margins =  _get_margins(self.crop_by)

        else: raise ValueError('"crop_by" must be a tuple with length 3 in the form ox (x,y,z) or ((x1,x2),(y1,y2),(z1,z2))')
        if any(self.margins) < 0: raise ValueError('cannot crop to a negative dimension')

        x = x.crop_3d(crop_by = self.margins, perc_crop = self.perc_crop).resize_3d(self.resize_to)
        return x if x.device.type == 'cpu' else x.cuda()

# Cell
@patch
def warp_3d(t: (TensorDicom3D,TensorMask3D), magnitude_x, magnitude_y):

    '''
    A function to warp a 3D image using torch.nn.functional.grid_sample

    Taken form the offical documention:
        Given an input and a flow-field grid, computes the output using input values and pixel locations from grid.
        In the spatial (4-D) case, for input with shape (N,C,Hin,Win) and with grid in shape (N, Hout, Wout, 2), the output will have shape (N, C, Hout,Wout)

        In the case of 5D inputs, grid[n, d, h, w] specifies the x, y, z pixel locations for interpolating output[n, :, d, h, w].
        mode argument specifies nearest or bilinear interpolation method to sample the input pixels.

    Workflow of this function:
    1. create a fake RGB 3D image through generating fake color channels.
    2. add a 5th batch dimension
    3. create a flow-field for rescaling:
        a. creat2 two 1D tensor giving a linear progression from -1 to 0 and 0 to 1 with differnt number of steps, then merge them to one tensor
        b. creat a mesh-grid (the flow field) from x,y,z tensors from (a)
    4. resample the input tensor according to the flow field
    5. remove fake color channels and batch dim, returning only the 3D tensor

    Args:
        t (Tensor): a Rank 3 Tensor to be resized

    '''

    typ = type(t)
    z,x,y = t.shape # for a reason, I do currently not understand, order of the axis changes from resampling. flipping the order of x,y,z is the current workaround. z axis is now the slice axis

    t = torch.stack((t,t,t)) # create fake color channel
    t = t.unsqueeze(0).float() # create batch dim

#    magintude_y = random.randint(4, 25)
#    magintude_x = random.randint(4, 25) # magnitude 5 is equal magintude 0.2 for fastai warp class

 #   warp_x = random.randint(-x//magintude_x, x//magintude_x) # no warping along the z axis (wraping only on 2D slices)
 #   warp_y = random.randint(-y//magintude_y, y//magintude_y)

    warp_x = int(x*magnitude_x)
    warp_y = int(y*magnitude_y)


    warp_x1 = round(float(x)/2 + warp_x)
    warp_x2 = x - warp_x1

    warp_y1 = round(float(y)/2 + warp_y)
    warp_y2 = y - warp_y1

    x = torch.cat(
        (torch.linspace(-1, 0, warp_x1),
        torch.linspace(0, 1, warp_x2+1)[1:]))
    y = torch.cat(
        (torch.linspace(-1, 0, warp_y1),
        torch.linspace(0, 1, warp_y2+1)[1:]))# without the +1)[1:] two 0 would be in the merged linspaces
    z = torch.linspace(-1, 1, z)

    meshx, meshy, meshz = torch.meshgrid((x, y, z)) #
    grid = torch.stack((meshy, meshx , meshz), 3) # create flow field. x and y need to be switched as otherwise the images are rotated.
    grid = grid.unsqueeze(0) # add batch dim
    if t.device.type == 'cuda': grid = grid.cuda()

    out = F.grid_sample(t, grid, align_corners=True, mode = 'bilinear') # rescale the 5D tensor
    out = out[0,0,:,:,:].permute(2,0,1).contiguous() # remove fake color channels and batch dim, reorder the image (the Z axis has moved to the back...)
    return retain_type(out, typ = typ)

@patch
def warp_4d(t: Tensor, magnitude_x, magnitude_y):

    for i in range(0, t.size(0)):
        t[i,:,:,:] = warp_3d(t[i,:,:,:], magnitude_x=magnitude_x, magnitude_y=magnitude_y)
    return t


class RandomWarp3D(RandTransform):
    def __init__(self, p=0.5, max_magnitude = 0.25):
        super().__init__(p=p)
        self.max_magnitude = max_magnitude

    def before_call(self, b, split_idx):
        super().before_call(b, split_idx)

        self.magnitude_y= random.random()*self.max_magnitude
        self.magnitude_x = random.random()*self.max_magnitude

    def encodes(self, x:(TensorDicom3D,TensorMask3D)):
        x = x.warp_3d(magnitude_x = self.magnitude_x, magnitude_y = self.magnitude_y) if x.ndim == 3 else x.warp_4d(magnitude_x = self.magnitude_x, magnitude_y = self.magnitude_y)
        return x if x.device.type == 'cpu' else x.cuda()

# Cell

@patch
def add_gaussian_noise(t:TensorDicom3D, std):
    shape = torch.randn(t.shape).cuda() if t.device.type == 'cuda' else torch.randn(t.shape).cpu()
    return t + (std**0.5)*shape

class RandomNoise3D(RandTransform):
    def __init__(self, p=0.5):
        super().__init__(p=p)

    def before_call(self, b, split_idx):
        super().before_call(b, split_idx)
        low_std = float(random.randint(1,20))/100
        high_std = float(random.randint(20,30))/100
        self.std = random.choice((low_std, low_std, low_std, low_std, high_std)) # lower noise is oversampled, as high noise migh be bad for the model

    def encodes(self, x:TensorDicom3D):
        x = x.add_gaussian_noise(self.std)
        return x if x.device.type == 'cpu' else x.cuda()

# Cell

@patch
def rescale(t: TensorDicom3D, new_min = 0, new_max = 1):
    return (new_max - new_min)/(t.max()-t.min()) *(t - t.max()) + t.max()

@patch
def adjust_brightness(x:TensorDicom3D, beta):
    return torch.clamp(x + beta, x.min(), x.max())


class RandomBrightness3D(RandTransform):
    def __init__(self, p=0.5):
        super().__init__(p=p)

    def before_call(self, b, split_idx):
        super().before_call(b, split_idx)
        self.beta = float(random.randint(-300,400))/1000

    def encodes(self, x:TensorDicom3D):
        x = x.adjust_brightness(self.beta)
        return x if x.device.type == 'cpu' else x.cuda()


# Cell

@patch
def adjust_contrast(x:TensorDicom3D, alpha):
    return torch.clamp(alpha * x, x.min(), x.max())


class RandomContrast3D(RandTransform):
    def __init__(self, p=0.6):
        super().__init__(p=p)

    def before_call(self, b, split_idx):
        super().before_call(b, split_idx)
        self.alpha = float(random.randint(940, 1150))/1000

    def encodes(self, x:TensorDicom3D):
        x = x.adjust_contrast(self.alpha)
        return x if x.device.type == 'cpu' else x.cuda()

# Cell

@patch
def make_pseudo_color(t: (Tensor, TensorDicom3D, TensorMask3D)):
    '''
    The 3D CNN still expects color images, so a pseudo color image needs to be created as long as I don't adapt the 3D CNN
    '''
    return torch.stack((t, t, t), t.ndim).float() if t.ndim in (3,4) else t # permute is an important step, ensuring rigth format of tensors

class PseudoColor(RandTransform):
    split_idx, p = None, 1

    def __init__(self, p=1):
        super().__init__(p=p)

    def __call__(self, b, split_idx=None, **kwargs):
        "change in __call__ to enforce, that the Transform is always applied on every dataset. "
        return super().__call__(b, split_idx=split_idx, **kwargs)

    def encodes(self, x:(TensorDicom3D, Tensor, TensorMask3D)):
        x = x.make_pseudo_color()
        return x if x.device.type == 'cpu' else x.cuda()

# Cell

def _set_p_tfms(p, p_all):
    return p_all if p is None else p

# Cell

def aug_transforms_3d(p_all = 0.1,
                      do_warp = True, p_warp = None,
                      do_dihedral = True, p_dihedral = None,
                      do_brightness = True, p_brightness = None,
                      do_contrast = True, p_contrast = None,
                      do_noise = True, p_noise = None,
                      do_rotate_by = True, p_rotate_by = None,
                      do_flip = True, p_flip = None,
                      do_rotate = True, p_rotate = None,
                      do_crop = True, p_crop = 1):
    tfms = []

    if do_warp: tfms.append(RandomWarp3D(p=_set_p_tfms(p_warp, p_all)))
    if do_dihedral: tfms.append(RandomDihedral3D(p=_set_p_tfms(p_dihedral, p_all)))
    if do_brightness: tfms.append(RandomBrightness3D(p=_set_p_tfms(p_brightness, p_all)))
    if do_contrast: tfms.append(RandomContrast3D(p=_set_p_tfms(p_contrast, p_all)))
    if do_noise: tfms.append(RandomNoise3D(p=_set_p_tfms(p_noise, p_all)))
    if do_rotate_by: tfms.append(RandomRotate3DBy(p=_set_p_tfms(p_rotate_by, p_all)))
    if do_flip: tfms.append(RandomFlip3D(p=_set_p_tfms(p_flip, p_all)))
    if do_rotate: tfms.append(RandomRotate3D(p=_set_p_tfms(p_rotate, p_all)))

    return tfms