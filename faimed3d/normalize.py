# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_normalization.ipynb (unless otherwise specified).

__all__ = ['ImageCorrectionWrapper']

# Cell
# default_exp normalize
import SimpleITK as sitk
from fastai.basics import *

# Cell
@patch
def freqhist_bins(t:(TensorDicom3D,Tensor), n_bins=100):
    '''
    A function to split the range of pixel values into groups, such that each group has around the same number of pixels.
    taken from https://github.com/fastai/fastai/blob/master/fastai/medical/imaging.py#L78
    '''
    imsd = t.view(-1).sort()[0]
    t = torch.cat([tensor([0.001]),
                   torch.arange(n_bins).float()/n_bins+(1/2/n_bins),
                   tensor([0.999])])
    t = (len(imsd)*t).long()
    return imsd[t].unique()

@patch
def hist_scaled(t:(TensorDicom3D,Tensor), brks=None):
    '''
    Scales a tensor using `freqhist_bins` to values between 0 and 1
    taken from https://github.com/fastai/fastai/blob/master/fastai/medical/imaging.py#L78
    '''
    if t.device.type=='cuda': return t.hist_scaled_pt(brks)
    if brks is None: brks = t.freqhist_bins()
    ys = np.linspace(0., 1., len(brks))
    x = t.numpy().flatten()
    x = np.interp(x, brks.numpy(), ys)
    x = tensor(x).reshape(t.shape).clamp(0.,1.)
    return x # will loose meta data in process

@patch
def hist_scaled_pt(t:(TensorDicom3D,Tensor), brks=None):
    "same as fastai fucntion for PILDicom"
    # Pytorch-only version - switch to this if/when interp_1d can be optimized
    if brks is None: brks = t.freqhist_bins()
    brks = brks.to(t.device)
    ys = torch.linspace(0., 1., len(brks)).to(t.device)
    return t.flatten().interp_1d(brks, ys).reshape(t.shape).clamp(0.,1.)

# Cell
@patch
def normalize(t:TensorDicom3D,
              norm_type = 'mean'):
    "normalizes a 3D Tensor, 0 voxels are not included for normalization"
    if norm_type == 'mean':
        mask = t.ne(0.)
        mean, sd = t[mask].mean(), t[mask].std()
        return (t - mean) / sd

    if norm_type == 'median':
        mask = t.ne(0.)
        if mask.view(-1).shape[0] >=2 **16:
            # resize to large tensor for quantile
            # qunatile takes up to size 2**24, but than takes ~1sec
            mask = F.interpolate(t[mask].view(-1).unsqueeze(0).unsqueeze(0), 2**16)
        median, iqr = mask.median(), mask.quantile(0.75)-mask.quantile(0.25)
        return (t-median)/iqr

    if norm_type == 'max':
        return (t - t.min()) / (t.max() - t.min())


# Cell
class ImageCorrectionWrapper(object):
    def __init__(self,
                 n4_max_num_it = 3,
                 hist_radius = [5,5,5], # radius in format [H x W x D]. Computation time scale ^3 with radius.
                 hist_alpha  = 0.3,
                 hist_beta = 0.3,
                 do_n4 = True,
                 do_hist = True,
                 verbose = True):
        store_attr()
        if do_n4:
            self.corrector = sitk.N4BiasFieldCorrectionImageFilter()

    def __call__(self, orig_file, fn_out=None):
        if isinstance(orig_file, str):
            if fn_out is None:
                fn_out = self.strip_suffix(fn_in)+'corrected.nii.gz'
            self.convert_string(orig_file, fn_out)
        if isinstance(orig_file, TensorDicom3D):
            if fn_out is None:
                try: fn_out = self.strip_suffix(orig_file.fn)+'corrected.nii.gz'
                except: raise ValueError('Please set a name for the output')
            self._convert(orig_file.as_sitk(), fn_out)
        if self.verbose:
            print('Coreccted and wrote file to {}'.format(fn_out))

    def convert_string(self, fn_in, fn_out):
        im = self.read_image(fn_in)
        self._convert(im, fn_out)

    def _convert(self, im, fn_out):
        if self.do_n4:
            im = self.n4_bias_correction(im)
        if self.do_hist:
            im = self.hist_equal(im)
        sitk.WriteImage(im, fn_out)


    def n4_bias_correction(self, im):
        self.corrector.SetMaximumNumberOfIterations([self.n4_max_num_it]*3)
        return self.corrector.Execute(im)

    def hist_equal(self, im):
        return sitk.AdaptiveHistogramEqualization(sitk.Cast(im, sitk.sitkInt16),
                                                  radius=self.hist_radius*3,
                                                  alpha=self.hist_alpha,
                                                  beta=self.hist_beta)

    def read_image(self, fn):
        "copy of TensorDicom3D.load"
        if isinstance(fn, str): fn = Path(fn)
        if fn.is_dir():
            SeriesReader = sitk.ImageSeriesReader()
            dicom_names = SeriesReader.GetGDCMSeriesFileNames(str(fn))
            SeriesReader.SetFileNames(dicom_names)
            im = SeriesReader.Execute()
            return sitk.Cast(im, sitk.sitkFloat32)
        elif fn.is_file():
            return sitk.ReadImage(str(fn), outputPixelType=sitk.sitkFloat32)
        else:
            raise TypeError('the path "{}" is neither a valid directory nor a file'.format(str(fn)))


    def strip_suffix(self, fn):
        fn = Path(fn)
        extensions = "".join(fn.suffixes)
        new_fn = str(fn).replace(extensions, '')
        return new_fn+'/' if fn.is_dir() else new_fn